        // HTTP(Hyper Text Transfer Protocol):
	// - 웹 상에서 데이터를 주고 받기 위한 통신 규약. 
	

	// GET / POST - 웹의 대화법 
	
	// GET : 서버로부터 데이터를 요청하거나 페이지를 요청할 때 사용 . 
	//		- 데이터를 가져오기만 함, 서버의 상태나 데이터에는 변화를 주지 않아야 함. 
	// 		- 쿼리스트링 : URL에 데이터를 덧붙여서 요청하는 방식 
	//		- GET /id?query = test
	
	// POST : 서버에 데이터를 보내 새로운 리소스를 생성하거나 특정 작업을 수행할 때 사용
	// 		- 서버나 데이터에 변화가 생길 수 있음 . 
	//		- Post는 데이터를 body에 데이터를 숨겨가기 때문에 민감정보를 다루기에 적합.
	
	
	// PUT : 서버의 기존 데이터를 완전히 새로운 데이터로 교체할 때 사용 
	//		- 기존 데이터가 있으면 덮어쓰고 없으면 새로 생성
	//		- 사용자 프로필 전체 업데이트 
	// 		- 무조건 다 바꾸는 것(부분적 변화는 없음)
	// 		- not safe 
	//   	- 멱등성(idempotent) : 특정 연산을 여러번 반복해도 결과가 변하지 않는 성질.
	//		- 말그대로 완전 교체이기 때문에 나머지 데이터들이 소실될 가능성도 있음.
	
	
	// PATCH : 필요한 부분만 정교하게 수정할 때 사용 
	// 		- 사용자 프로필에서 이메일 주소만 수정
	// 		- 멱등하지 않을 수 있음
	//		- 일부 데이터 수정
	//		- 트래픽(대역폭)을 아낄 수 있음 -> 서버의 부담이 줄어듬
	// 		- 불필요한 망치를 휘두르기 보다는 정교한 조각칼을 활용해야하는 순간도 있다.
	
	
	// DELETE : 대상을 완전히 제거(서버에서 특정 데이터를 삭제할 때 사용 ) 
	// 		- 안전하지 않고 상태 자체를 크게 변화 시킴
	//		- get으로 제거 자체를 처리하는 경우도 있음
	// 		- (검색 엔진 봇들이 우리 서비스에서 데이터를 지우는 재앙을 맞을 수도 있어서 요즘은 get으로 delete 안함.)
	//		- 멱등성 보장. 


	//---------------------------------------------------------------------------------------------------------------------------------
	<HTTP, HTTPS>
	// HTTPS : 웹 브라우저와 웹 서버간 안전한 통신을 제공하는 프로토콜
	// 	-> HTTP에 보안계층이 추가된 형태. 
	// 	-> 데이터에 암호화가 추가된다. (네트워크 상에서 도청, 데이터변조, 스니핑 등의 공격으로부터 보호)
	
	// HTTP : 누구나 확인하고 탐색할 수 있는 투명한 데이터
	//		-> 기본 80번 포트 사용
	
	// HTTPS : 완전 꽁꽁 싸맨 안전한 데이터( SSL/TLS)
	// 		-> 기본 443번 포트를 사용
	
	<HTTPS 의 3대 보안 원칙 >
	// 1. 기밀성(Confidentiality) : 암호화로 내용 숨기기
	// 2. 무결성(Integrity) : 전자서명으로 변조를 방지.
	// 3. 인증(Authentication) : 적합한 유저인지 확인. 
	
	<HTTP 통신의 4대 철학>
	// 1. 클라이언트 - 서버 모델
	// 2. 요청 - 응답 구조
	// 3. 비연결성 : 필요할때만 만나는 깔끔한 관계
	// 4. 무상태성 : 과거를 기억하지 않는 이너피쓰한 마음
	
	
	<HTTP 구조 분석>
	// 전체 요청라인 : GET /api/customers/123 HTTP/1.1
	
	// HTTP는 크게 헤더, 바디로 나눠봄 
	
	// [헤더를 구성하는 내용]
	// Host : 어느집으로 갈것인가(어느 주소로 갈것인가?)
	// User-Agent : 유저 확인
	// Accept : 나는 이런걸 받고 싶어요 라는 요청사항(req) 
	
	// [응답관련(응답 헤더) 상태코드 200이라는 것을 받을때 정확한 데이터를 전송]
	// Content-Type : 응답으로 오는게 뭔지 알려주는 라벨
	// Content-Length : 응답으로 오는 데이터의 크기를 알려주는 상태 코드 

         <HTTP 통신 프로세스>
	// 1. TCP 연결
	// 		TCP(Transmission Control Protocol) 란???
	// 		- 컴퓨터 네트워크에서 데이터를 안정적이고 신뢰성 있게 전달할 수 있도록 사용하는 프로토콜
	// 		- 인터넷의 IP 사이에서 동작하기 때문에 IP와 자주 엮임.
	// 		- 하는일 : 데이터의 전송이 올바르게 이루어졌는지 확인, 
	// 				손실이나 손상을 복구하는 기능을 제공 
	
	// 		[TCP 특징]
	// 		- 연결지향적 : 데이터를 전송하전에 송 수신자 간의 연결을 설정
	// 				(연결은 3-way 핸드 셰이크 과정을 통해 이루어짐) 
	// 		- 신뢰성 확보 : 데이터가 제대로 도착했는지 확인 하는 과정이 필요
	// 		- 흐름 제어 : 데이터 양을 초과하지 않도록 관리
	// 		- 혼잡 제어 : 효율적으로 데이터를 조정하여 전송 
	// 		- 데이터 스트림 분할 및 재조립
	
	
	// 2. HTTP 메세지 전송 : 작성한 요청을 보낼 준비
	// 3. 서버의 처리 : 서버가 요청을 차근차근 처리 
	// 4. 응답 수신 : 서버가 요청에 대해 응답을 처리 
	// 5. 연결종료 혹은 재사용 

                
	//--------------------------------------------------------------------
	//	GET 방식으로 서버에 요청할때의 예시.
	//	GET /api/customers/123 HTTP/1.1
	//	Host: api.example.com
	//	User-Agent: TangoSword/1.0
	//	Accept: application/json
	//	Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
	//
	//	서버의 성공 응답 예시
	//	HTTP/1.1 200 OK
	//	Content-Type: application/json
	//	Content-Length: 156
	//	Cache-Control: max-age=3600
	//
	//	{
	//	  "id": 123,
	//	  "name": "홍길동",
	//	  "email": "hong@example.com",
	//	  "created_at": "2025-09-01T13:50:00Z"
	//	}

                
        //--------------------------------------------------------------------
	 <HTTPS는 그렇다면 어떤식으로?>
	// 1. 클라이언트의 요청
	// 	- HTTP와의 차이점은 안전한 연결 요청이 들어온다 정도.
	// 2. SSL 인증서 전송 : 서버가 신원을 증명하는 증명서를 전송
	// 	- SSL : Secure Sockets Layer
	// 		    웹 서버와 클라이언트간의 안전한 통신을 위해 설계된 프로토콜
	//  - SSL의 기능 : 데이터 암호화, 인증, 데이터 무결성 보장 기능
	// 3. 인증서 검증 : 인증서가 진짜인지 브라우저가 확인해줌. 
	// 4. 세션 키 교환 : 암호화에 사용할 비밀 열쇠를 나눠가진다. 
	// 5. 암호화된 통신 시작 : 모든 요청, 응답들이 암호화 되어 진행 

                
        //--------------------------------------------------------------------
        // TLS : SSL 후속 프로토콜 , 보안성을 강화하고 성능을 개선한 버전 
	
	// <HTTP vs HTTPS>
	// 보안성은 HTTPS가 우수
	// - SEO 점수 부분도 차이가 생김.
	// - 성능은 HTTP 쪽이 더 우수.
	// - 무엇을 선택하는지에는 상황에 따라 다름.
	
	
	//--------------------------------------------------------------------
	// <HTTP Staus Code(403, 404, 500, 200)>
	// 상태코드 : 클라이언트가 서머에게 요청을 보내면 서버는 일을 처리한 후 
	// 		   결과는 이거에요 ! 라고 알려주는 세자리 숫자를 보냄. 이것이 
	// 		   Http Status Code
	
	// 누렁이가 냄새로 구분하는 상태 코드들
	// 100 ~ 500
	
	// 1xx(정보 냄새) : 아직 처리중이라는 미묘한 냄새 (거의 안씀) 
	// 2xx(성공한 간식 냄새) : 모든게 잘 됐다는 의미.
	// 3xx(자리 이동 냄새) : 원래 있던 곳에서 사라졌으니 다른 곳으로 가봐라. 
	// 4xx(클라이언트 실수 냄새) : 클라이언트가 실수한 냄새임. 서버(개발자)는 잘못 없음
	// 5xx(서버가 아픈 냄새) : 서버가 불타는 냄새.

                
	//--------------------------------------------------------------------
	// 2xx : 성공한 간식 냄새 
	
	// 200 OK
	// 	- 가장 완벽하고 맛있는 최고급 성공 간식 냄새 !
	// 	- 요청이 성공적으로 처리되었고 그에 대한 응답 정보도 함께 보낸다.
	//  - (가장 일반적인 성공 코드) 
	//  - 단, 제대로 된 응답이 갔는지 제대로 test를 통해 확인해야 함!!
	
	// 201 Created
	//  - 갓 구운 따끈따끈한 새 간식 냄새 !
	// 	- 클라이언트의 요청으로 새로운 것이 만들어졌을때 오는 응답.
	// 	- POST 요청이 성공적으로 처리되어 새로운 리소스(데이터)가 생성되었을 때 사용
	//    (이 응답은 보통 Location 헤더에 새로 만들어진 리소스 주소를 포함해
	//	   여기에 만들었음 ! 이라고 알려주는 것이 제일 좋은 예시) 
	//	- ex) 회원가입에 성공하고 새로 생성된 사용자 정보와 함께 응답할 때. 
	
	// 204 No Content
	//  - 냄새는 좋은데 먹을 건 없는 빈 그릇 냄새 !
	//  - 처리는 성공했으나 딱히 돌려줄 리턴 결과는 x
	//  - 요청은 성공적으로 처리했지만 응답 본문에 보낼 데이터가 없을 때 사용 
	//  - ex) 무언가를 삭제했을 때

                
	//--------------------------------------------------------------------
	// 3xx - 자리 이동
	
	// http://nureong.com -> https://nureong.com 는 완전히 다른 주소. 
	
	// 301 Moved Permanently
	//  - 영원히 이사갔다는 얘기. 새 주소로 찾아와라 !
	// 	- 요청한 주소가 영구적으로 변경됐을 때 사용.
	// 	- 브라우저나 검색 엔진은 이 응답을 받으면 앞으로는 새로운 주소로만 요청을 보냄.
	//  - 회사들이 웹 사이트 주소를 변경한다면 이는 아주 중요하다. 
                
        // 304 Not Modified
	//  - 어제 먹다남은 간식 냄새( 네가 가진 간식이랑 똑같은 것)
	//  - 새 거 아니니까 그냥 그거 먹어라 ! 배고프게 기다릴 것이 없다. 
	//  - 클라이언트가 이러한 데이터가 있는데 바뀐 거 있어? 라고 물어봤을때, 
	// 	  서버는 바뀐 거 없으니 그대로 쓰라고 응답하는 것.
	//  - 불필요한 데이터 전송을 막아 성능을 높여줄 때 사용
	//  - ex) 브라우저가 변경되지 않은 어제 본 이미지를 다시 요청할 때 
	
	
	//--------------------------------------------------------------------
	// 4xx - 클라이언트의 실수 냄새
	//  - 퀴퀴하고 수상한 냄새. 
	//	- 서버 잘못이라기 보단, 클라이언트가 요청을 보낼 때, 실수했을 확률이 높다. 그러니 다시 확인해봐라!!
	
	// 400 Bad Request
	//  - 상한 음식을 보낸 냄새 ! 서버가 도저히 이해할 수 없는 이상한 요청을 보냄 
	//  - 요청 문법 문제, 필수 파라미터 누락, 데이터의 형식이 안맞는 경우.
	//   (가장 포괄적인 클라이언트 에러)
	//  - 400 에러가 뜬다 하더라도 사용자에게 우선 안내할 필요가 있음.
	//  - ex) 회원가입시 이메일이 필수항목인데 누락. 
                
        // 401 unAuthorized
	//  - 수상한 인간! 왈왈! 인증 먼저 해라 !!!
	//  - 권한 없음 x / 인증이 안됨. 신원확인(로그인)이 필요한데 
	//				 요청에 유효한 인증 정보가 없는 상태(로그인 토큰 or 키 값)
	// 	- 로그인을 해야지만 볼 수 있는 페이지에 (인증정보없이 / 토큰없이) 접근하려할 때 
	
	// 403 Forbidden
	//  - 아는 냄새지만 너는 여기 들어오면 안됨!
	// 	- 권한이 없다. 인가가 되지 않았다. 
	//  - 신원 확인은 성공했지만(인증은 성공)
	//	- But, 해당 영역(리소스)에 접근할 권한이 없을 때, 발생하는 에러(인가 실패)
	// 	- 관리자 페이지 등에서 많이 나올 수 있는 에러. 
	
	// 404 Not Found
	//  - 아무 냄새도 안나는 텅 빈 공간의 냄새! 클라이언트가 찾는 건 없어 ㅠ
	//  - 요청한 주소에 해당하는 내용이 서버에 없는 경우
	//  - 존재하지 않는 영역 혹은 존재하지 않는 유저에 대한 정보 요청 
	
	// 405 Conflict
	//  - 충돌
	//  - 내 밥그릇에 다른 개 이름이 써져있다는 냄새
	//  - 이미 주인이 있는 물건 = 요청이 현재 서버의 상태와 충돌했다. 
	// 	- 이미 존재하는 이메일 주소로 회원가입을 시도할 때. 
	//  - 그래서 트랜잭션을 통해 올바른 커밋, 롤백이 가능해야 함 .
	
	
	//--------------------------------------------------------------------
	// 5xx - 서버가 아픈 냄새(개발자가 뭔가 실수함) 
	
	// 500 Internal Server Error
	//  - 서버가 아파서 비명을 지르는 냄새! 서버 내부에서 뭔가 이상한 큰 문제 발생.
	//  - 서버 코드에 에러가 있거나 DB 연결 실패 등 천재 지변을 포함한 서버쪽 에러. 
	//  - 클라이언트가 이 에러내용을 확인해서는 안됨
	// 	  (정확히는 보여주면 안됨. 개발자는 로그를 확인하고 재빠르게 수정) 

        // 502 Bad Gateway
	//  - 문지기가 저 안쪽에 있는 서버와 싸웠다! (안쪽 서버 녀석이 이상한 대답을 함) 
	//  - Gateway(게이트 웨이) : 네트워크간의 데이터 전송을 가능하게 하는 장치 
	//		- 서로 다른 네트워크 프로토콜을 사용하는 두 네트워크 사이의 연결을 관리하고 
	//		  데이터를 변환시켜 서로 통신할 수 있도록 도움을 줌 
	//  - Proxy(프록시) : 중간에서 대리 역할을 수행하는 개체 혹은 시스템(중계 서버) 
	//  - 502는 웹 서버가 실제 로직을 처리하는 서버로부터 유효하지 않은 응답을 받을 때
	
	// 503 Service Unavailable
	//  - 서버가 잠시 기절한 냄새
	//  - 너무 많은 요청을 받아서 지쳤거나 혹은 서버가 동작하고있지 않거나
	//  - 과부하 or 서버 점검중. 







